## How to prepare for QA Engineer interviews?
* [Public interview for Software test automation engineer with JavaScript](https://www.youtube.com/watch?v=fSO6hEe5fZU)

#### Primary skills:
1. JavaScript

### Secondary skills:
1. Puppeteer / Cypress - Automation **frameworks**
2. Axios - for testing **API**
3. Jest / Chai / Mocha - фреймворки/библиотеки

### Обязанности:
1. Работа в 3х командах: Web, Mobile и API
2. Тестирование Web приложения
3. Тестирование Mobile и Tablet. Нет mobile приложения, есть web-mobile (адаптивная вёрстка) + web-tablet (адаптивная вёрстка)
4. Приложение реализовано на 3х языках, авто-тесты покрывают всю локализацию
5. Тестирование динамических данных и статики по мокам:
   1. Моки динамические получаем с бэкенда (через **graphql** по отдельному контракту) и сравниваем с данными на сайте
   2. Статику проверяем с моками из репозитория
6. Отвечал за разработку фреймворка/показ и продажу клиенту
7. Onboarding людей
8. Написание авто-тестов, unit тесты:
   1. Тесты покрываются проверками для мёрджа в репозиторий:
      1. Prettier + Lint - **code quality rules**
9. Сбор метрик по покрытию авто-тестами приложения через **Test-rail** (отчеты по статусу)

### Вопросы:
10. **Эстимация** (продакт/команда) в каких единицах?
    1. Эстимация оценивается в задачах (маленькая/средняя/большая) и взять среднее время
    2. Эстимация оценивается в средней работе сотрудников (джуны/мидлы/синьёры)
    3. Эстимация оценивается в числах фибаначи
    4. Не оценивать в часах
    5. Учитывать не только заболевания/увольнения, но и сложность задачи, риски связанные с интеграциями, инструментами, технической сложностью задачи.
11. Пороги входа в разные **фреймворки**. Документация, комьюнити, скорость, мультибраузер
12. **triple A principle** - проще сделать атомарными, переносить и убирать
    1. Arrange - data set
    2. Act - действие
    3. Assert - проверка
13. Виды **Дизайн паттернов**:
    1. **Page Object** Model - classes and various UI elements of that page are defined as variables
    2. **Builder** pattern - allows a client to construct a complex object by specifying the type and content only.
       1. Создание объекта по частям. Объект может иметь те или иные сущности без хранения огромного монолита
    3. **Factory** design pattern - superclass with multiple subclasses, based on some input 
    4. **Facade** pattern - class which has methods that combine actions executed on different pages
    5. **Singleton** pattern - only one instance of it can exist at any time. Returns the same instance every time
       1. часто используется по умолчанию в JS. Помогает работать с памятью более эффективно
14. **Дизайн паттерны** помогают:
    1. лёгкое поддержание кода чистым, 
    2. организованный код для себя и команды,
    3. переиспользуемость кода
15. **Параллелизация** тестов - 
    1. Запустить все тесты и равномерно распределить их по разным нодам можно с помощью инструкции **parallel** в Cypress. 
       1. Она нужна для того, чтобы запускать одну и ту же джобу несколько раз параллельно.
    2. Через **Jenkins** костыльно можно настроить параллель
    3. Через **Docker** локально в контейнерах тесты поднять
    4. **TeamCity**
    5. **Selenoid** — это программа, которая позволяет управлять браузерами и Android-эмуляторами с помощью специальных драйверов. Умеет запускать каждый из них изолированно в Docker-контейнере. Selenoid представляет собой альтернативное решение Selenium Server, хотя суть та же — организация работы драйверов.
16. Проблемы с Параллелизацией:
    1. Нагрузка системы (память для потоков)
    2. Работа с аккаунтами (поддерживать несколько аккаунтов)
    3. Проблема с данными (дирижировать тестами, запускать в определенном порядке чтобы тесты не мешали друг другу)
17. Какие тест-кейсы для PUT запроса? 
    1. Проверить status code
    2. Схема (ответа, который вернулся)
    3. Контент если не слишком большой контент (если возможно проверить) или проверить поля, которые нам нужны
    4. Проверка позитивного сценария - PUT что-то updated
    5. Негативные сценарии: 
       1. как запрос реагирует на неправильный ввод
       2. неправильные headers
       3. как запрос ведёт себя если слабый коннект (особенно если PUT связан с большими документами/картинками)
18. Для **тестирования API** подойдёт любой НЕ UI framework:
    1. **Mocha**
    2. **Jest**
19. Tool для отправки запросов при **тестировании API**:
    1. **Axios** - core пакет, который позволяет много чего делать с запросом
    2. **request-promise**
    3. **newman** - надстройка для postman
20. Варианты для улучшения ресурсов автоматизации:
    1. Выбор наиболее подходящего ПО для автоматизации (под проект, потребности проекта)
    2. Коммуникации с Девопс/разработкой, репозитории/селекторы
    3. Параллелизация
    4. Сделать код наиболее поддерживаемым (использовать паттерны код дизайна)
       1. export отдельных частей, а не целого файла/блока
       2. Переменные для окружения, data, функций и проверок
       3. Моки (динамические + статика)
       4. Архитектура проекта
    5. Preconditions (чать вынести на API)
    6. Избавиться от дубликации проверок в тестах на разных уровнях
21. JS runners (**frameworks**):
    1. **Jest**
    2. **Mocha**
    3. **Jasmine**
    4. **Testing library**
    5. **Cypress**
    6. **Playwright**
    7. **Storybook**
    8. **Puppeteer**
    9. **Ava**
    10. **WebdriverIO**
    11. **Selenide** - это обёртка вокруг Selenium WebDriver, позволяющая быстро и просто его использовать при написании тестов, сосредоточившись на логике, а не суете с браузером.
22. 